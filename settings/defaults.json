{
    "control_panel": {
        "name": "Control panel",
        "settings": {
            "core_rf_sensor_class": {
                "help": "RF sensor class to use for the control panel",
                "type": "class",
                "module": "zigbee.XBee_Sensor",
                "required": true,
                "replace": [" ", "_"],
                "default": "XBee_CC2530_Sensor_Physical"
            }
        }
    },
    "control_panel_loading": {
        "name": "Control panel (loading view)",
        "settings": {
            "loading_insertion_delay": {
                "help": "Frequency in seconds to check for a newly inserted RF sensor",
                "type": "float",
                "min": 0.0,
                "default": 0.1
            }
        }
    },
    "control_panel_devices": {
        "name": "Control panel (devices view)",
        "settings": {
            "devices_discover_delay": {
                "help": "Frequency in seconds to handle a discovered RF sensor",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            }
        }
    },
    "control_panel_planning": {
        "name": "Control panel (planning view)",
        "parent": "planning",
        "settings": {
            "planning_update_interval": {
                "help": "Frequency in seconds to handle planning algorithm updates. This depends on the `iteration_callback` setting and the speed of the algorithm run.",
                "type": "float",
                "min": 0.0,
                "default": 0.2
            },
            "planning_plot_dimensions": {
                "help": "Size in pixels for the width and height, respectively, of the Pareto front viewer",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [550, 550]
            }
        }
    },
    "control_panel_reconstruction": {
        "name": "Control panel (reconstruction view)",
        "parent": "reconstruction",
        "settings": {
            "reconstruction_curve_points": {
                "help": "Number of points to show on a plotted curve",
                "type": "int",
                "min": 5,
                "default": 20
            },
            "reconstruction_pause_time": {
                "help": "Delay in seconds to wait before entering the next reconstruction loop iteration",
                "short": "Pause time",
                "type": "float",
                "min": 0.0,
                "default": 0.02
            }
        }
    },
    "control_panel_settings": {
        "name": "Control panel (settings view)",
        "settings": {
            "settings_max_retries": {
                "help": "Number of retries for every setting packet sent to a vehicle",
                "type": "int",
                "min": 1,
                "default": 5
            },
            "settings_retry_interval": {
                "help": "Frequency in seconds to retry sending a setting packet to a vehicle",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            }
        }
    },
    "control_panel_waypoints": {
        "name": "Control panel (waypoints view)",
        "settings": {
            "waypoints_max_retries": {
                "help": "Number of retries for every waypoint packet sent to a vehicle",
                "type": "int",
                "min": 1,
                "default": 5
            },
            "waypoints_retry_interval": {
                "help": "Frequency in seconds to retry sending a waypoint packet to a vehicle",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            }
        }
    },
    "distance_sensor_simulator": {
        "name": "Distance sensor (simulator)",
        "settings": {
            "altitude_margin": {
                "help": "Difference in altitude in meters at which simple objects are still visible",
                "type": "float",
                "min": 0.0,
                "default": 2.5
            },
            "angle_margin": {
                "help": "Difference in angle in degrees at which simple objects are still visible",
                "type": "float",
                "min": 0.0,
                "default": 5.0
            },
            "maximum_distance": {
                "help": "Maximum distance in meters at which an object is still visible",
                "type": "float",
                "min": 0.0,
                "default": 1000.0
            }
        }
    },
    "distance_sensor_physical": {
        "name": "Distance sensor (physical)",
        "settings": {
            "trigger_pin": {
                "help": "GPIO board pin to use for the HC-SR04 trigger pin",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 13
            },
            "echo_pin": {
                "help": "GPIO board pin to use for the HC-SR04 echo pin",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 11
            },
            "trigger_delay": {
                "help": "Time in seconds to wait for the trigger pin to become active",
                "type": "float",
                "min": 0.0,
                "default": 0.00001
            },
            "interval_delay": {
                "help": "Time in seconds to wait after making the pins ready for measurements",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            },
            "speed_of_sound": {
                "help": "Speed of sound in cm/s",
                "type": "float",
                "min": 0,
                "default": 34320
            }
        }
    },
    "infrared_sensor": {
        "name": "Infrared sensor",
        "settings": {
            "remote": {
                "help": "Remote control configuration name. The program must run as root if a new remote is used.",
                "type": "file",
                "required": true,
                "format": "control/remotes/{}.lircrc",
                "default": "Sony_RM-SRB5"
            },
            "program": {
                "help": "Program name",
                "type": "string",
                "required": true,
                "default": "mobile-radio-tomography"
            },
            "buttons": {
                "help": "Registered buttons",
                "type": "list",
                "subtype": "string",
                "default": ["start", "stop", "up", "down", "left", "right"]
            },
            "wait_delay": {
                "help": "Delay in seconds for the infrared sensor thread",
                "type": "float",
                "min": 0.0,
                "default": 0.05
            }
        }
    },
    "line_follower_base": {
        "name": "Line follower base",
        "settings": {
            "readable_leds": {
                "help": "LED list indices to be used by the line follower",
                "type": "list",
                "length": 4,
                "subtype": "int",
                "min": 0,
                "default": [0, 2, 3, 5]
            },
            "line_threshold": {
                "help": "Threshold in microseconds above which a LED measurement is considered black",
                "type": "int",
                "min": 0,
                "default": 300
            }
        }
    },
    "line_follower_raspberry_pi": {
        "name": "Line follower (Raspberry Pi)",
        "parent": "line_follower_base",
        "settings": {
            "led_pins": {
                "help": "Raspberry Pi GPIO pins for the measurement LEDs",
                "type": "list",
                "subtype": "int",
                "min": 1,
                "default": [29, 31, 32, 33, 35, 36]
            },
            "emitter_pin": {
                "help": "Raspberry Pi GPIO pin for the emitter signal",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 37
            },
            "write_delay": {
                "help": "Delay in seconds to wait after changing the emitter signal",
                "type": "float",
                "min": 0.0,
                "default": 0.0002
            },
            "max_value": {
                "help": "Maximum value read from the line follower in microseconds",
                "type": "int",
                "min": 0,
                "default": 1023
            },
            "charge_delay": {
                "help": "Delay in seconds to wait after charging the measurement pins",
                "type": "float",
                "min": 0.0,
                "default": 0.00001
            }
        }
    },
    "line_follower_arduino": {
        "name": "Line follower (Arduino)",
        "parent": "line_follower_base",
        "settings": {}
    },
    "mission": {
        "name": "Drone trajectory mission data",
        "settings": {
            "altitude_undershoot": {
                "help": "Ratio of requested altitude which is allowed for takeoff altitude",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.95
            },
            "closeness": {
                "help": "Difference in meters at which we consider locations to be equal for waypoints, too close to detected objects, or in other mission movements. Set to 0 to disable.",
                "type": "float",
                "min": 0.0,
                "default": 2.0
            },
            "farness": {
                "help": "Distance in meters above which we are uninterested in detected objects",
                "type": "float",
                "min": 0.0,
                "default": 100.0
            },
            "mission_delay": {
                "help": "Delay in seconds to ensure that vehicle mission information is displayed cleanly",
                "type": "float",
                "min": 0.0,
                "default": 2.0
            },
            "altitude": {
                "help": "Altitude in meters to take off to. Ignored for ground vehicles.",
                "type": "float",
                "default": 4.0
            },
            "padding": {
                "help": "The space around the vehicle's center (where the distance sensor is) in which we do not want to have other objects. Used for additional padding aside from the closeness in certain calculations.",
                "type": "float",
                "min": 0.0,
                "default": 4.0
            },
            "speed": {
                "help": "Movement speed in m/s",
                "type": "float",
                "min": 0.0,
                "default": 2.5
            },
            "space_size": {
                "help": "Size in meters of one dimension of the part of the space that the vehicle is allowed to be in",
                "type": "float",
                "min": 0.0,
                "default": 10.0
            },
            "resolution": {
                "help": "The number of entries in the memory map per meter in one dimension",
                "type": "int",
                "min": 1,
                "default": 1
            },
            "yaw_step": {
                "help": "Difference of angle in degrees to change the yaw with in steps of some missions",
                "type": "float",
                "default": 10.0
            },
            "mission_class": {
                "help": "Mission class to use for the mission",
                "type": "class",
                "module": "mission",
                "default": "Mission_Cycle"
            },
            "measurement_delay": {
                "help": "Time in seconds to wait at a waypoint to perform synchronized measurements",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            },
            "rf_sensor_synchronization": {
                "help": "Whether to wait for measurements to be complete at waypoints",
                "type": "bool",
                "default": true
            }
        }
    },
    "mission_monitor": {
        "name": "Mission monitoring",
        "settings": {
            "step_delay": {
                "help": "Delay in seconds to wait before monitoring again",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            },
            "plot": {
                "help": "Whether to display an interactive plot of the memory map (requires matplotlib)",
                "type": "bool",
                "default": true
            },
            "viewer": {
                "help": "Whether to display a viewer of the current vehicle's sight (requires pyglet and a simulated environment)",
                "type": "bool",
                "default": true
            }
        }
    },
    "environment": {
        "name": "Vehicle environment",
        "settings": {
            "geometry_class": {
                "help": "Geometry to use for location calculations",
                "type": "class",
                "module": "geometry",
                "default": "Geometry_Spherical"
            },
            "distance_sensors": {
                "help": "Yaw angle in degrees for each distance sensor",
                "type": "list",
                "subtype": "float",
                "default": [0.0]
            },
            "servo_pins": {
                "help": "Servo pin number and duty cycle ranges for the servo rail.\nEach item contains the following keys and values:\n- 'pin': a pin number of the servo rail or GPIO port\n- 'angles': a tuple of minimum and maximum angles in degrees that the servo can turn to\n- 'pwm': a tuple of minimum and maximum PWM values (duty cycle)",
                "type": "list",
                "subtype": "dict",
                "dictinfo": {
                    "pin": {
                        "type": "int",
                        "min": 1,
                        "max": 40
                    },
                    "angles": {
                        "type": "tuple",
                        "length": 2,
                        "subtype": "int",
                        "min": 0,
                        "max": 360
                    },
                    "pwm": {
                        "type": "tuple",
                        "length": 2,
                        "subtype": "int"
                    }
                },
                "default": [
                    {
                        "pin": 7,
                        "angles": [0,360],
                        "pwm": [1000,2000]
                    }
                ]
            },
            "rf_sensor_class": {
                "help": "RF sensor class to use for the environment",
                "type": "class",
                "module": "zigbee.XBee_Sensor",
                "required": false,
                "replace": [" ", "_"],
                "default": ""
            },
            "infrared_sensor": {
                "help": "Whether to use the infrared sensor for starting and stopping a mission",
                "type": "bool",
                "default": true
            },
            "scenefile": {
                "help": "VRML file to import as simulated environment",
                "type": "file",
                "format": "tests/vrml/{}.wrl",
                "required": false,
                "default": null
            },
            "translation": {
                "help": "Differences in meters to offset the simulated environment with",
                "type": "tuple",
                "length": 3,
                "subtype": "float",
                "default": [0.0,0.0,0.0]
            },
            "location_check": {
                "help": "Whether to enable collision checks in a simulated environment",
                "type": "bool",
                "default": false
            }
        }
    },
    "environment_viewer": {
        "name": "Environment 3D scene viewer",
        "settings": {
            "max_points": {
                "help": "Maximum number of recently detected points to keep in the viewer",
                "type": "int",
                "min": 0,
                "default": 200
            }
        }
    },
    "environment_viewer_interactive": {
        "name": "Interactive environment 3D scene viewer",
        "parent": "environment_viewer",
        "settings": {
            "camera_move_speed": {
                "help": "Speed in m/s to move the camera while strafing. Negative value causes inverted controls.",
                "type": "float",
                "default": 5.0
            },
            "camera_rotate_speed": {
                "help": "Speed in degrees/s to rotate the camera. Negative value causes inverted controls.",
                "type": "float",
                "default": 90.0
            }
        }
    },
    "vehicle": {
        "name": "Vehicle interface",
        "settings": {
            "vehicle_class": {
                "help": "Vehicle backend to use",
                "type": "class",
                "module": "vehicle",
                "default": "Mock_Vehicle"
            }
        }
    },
    "vehicle_dronekit": {
        "name": "Dronekit vehicle backend",
        "settings": {
            "connect": {
                "help": "MAVLink connection string to the autopilot master",
                "type": "string",
                "default": "127.0.0.1:14550"
            },
            "mavlink_baud_rate": {
                "help": "Baud rate for the MAVLink connection",
                "type": "int",
                "min": 0,
                "default": 115200
            },
            "vehicle_simulation": {
                "help": "Whether to run the vehicle in a simulator rather than a physical environment",
                "type": "bool",
                "default": true
            },
            "gps": {
                "help": "Whether to wait for a GPS signal before starting",
                "type": "bool",
                "default": true
            }
        }
    },
    "vehicle_robot": {
        "name": "Base robot vehicle",
        "settings": {
            "diverged_speed": {
                "help": "Ratio of the current move speed to adapt when the vehicle diverges from a line",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.25
            },
            "diverged_time": {
                "help": "Time in seconds to keep adjusted speed when the vehicle diverges from a line",
                "type": "float",
                "min": 0.0,
                "default": 0.2
            },
            "rotate_speed": {
                "help": "Speed in m/s to use when the vehicle rotates on an intersection",
                "type": "float",
                "min": 0.0,
                "default": 0.30
            },
            "vehicle_delay": {
                "help": "Delay in seconds of the robot vehicle state loop",
                "type": "float",
                "min": 0.0,
                "default": 0.05
            },
            "line_follower_delay": {
                "help": "Delay of the sensor reading loop in the line follower thread",
                "type": "float",
                "min": 0.0,
                "default": 0.01
            },
            "home_location": {
                "help": "Home location coordinates of the vehicle. The vehicle should be placed at the intersection corresponding to these coordinates to begin with.",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [0, 0]
            },
            "home_direction": {
                "help": "The starting direction of the robot. The robot should be aligned with this direction to begin with. 0 is up, 1 is right, 2 is down and 3 is left.",
                "type": "int",
                "options": [0, 1, 2, 3],
                "default": 0
            }
        }
    },
    "vehicle_robot_raspberry_pi": {
        "name": "Robot vehicle directly connected to a Raspberry Pi",
        "settings": {
            "direction_pins": {
                "help": "Motor direction GPIO pins",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "max": 40,
                "default": [16, 18]
            },
            "motor_speed_pins": {
                "help": "Motor speed GPIO pins",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "max": 40,
                "default": [24, 26]
            },
            "motor_speed_pwms": {
                "help": "PWM range for both motors (minimum and maximum value)",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [0, 255]
            },
            "motor_speeds": {
                "help": "Speed range for both motors in m/s",
                "type": "tuple",
                "length": 2,
                "subtype": "float",
                "min": 0.0,
                "default": [0, 0.60]
            }
        }
    },
    "vehicle_robot_arduino": {
        "name": "Robot vehicle connected through an Arduino with a serial connection",
        "settings": {
            "motor_speed_pwms": {
                "help": "PWM range for both motors (minimum and maximum values)",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "default": [-400, 400]
            },
            "motor_speeds": {
                "help": "Speed range for both motors in m/s",
                "type": "tuple",
                "length": 2,
                "subtype": "float",
                "default": [-0.60, 0.60]
            }
        }
    },
    "planning": {
        "name": "Base trajectory planning",
        "settings": {
            "algorithm_class": {
                "help": "The evolutionary algorithm to use for the planning problem. It can be given with dashes instead of underscores and with lowercase letters.",
                "short": "Algorithm",
                "type": "class",
                "module": "planning.Algorithm",
                "replace": ["-", "_"],
                "default": "SMS_EMOA"
            },
            "discrete": {
                "help": "Whether to use discrete grid cells instead of allowing measurements to happen anywhere",
                "short": "Discrete",
                "type": "bool",
                "default": false
            }
        }
    },
    "planning_algorithm": {
        "name": "Evolutionary multiobjective optimization algorithm",
        "settings": {
            "population_size": {
                "help": "Number of individuals to use during optimization. Afterward, at most this number of nondominated solutions is presented.",
                "short": "Population",
                "type": "int",
                "min": 1,
                "default": 15
            },
            "iteration_limit": {
                "help": "Number of iterations to run optimization for",
                "short": "Iterations",
                "type": "int",
                "min": 0,
                "default": 1000
            },
            "iteration_callback": {
                "help": "Number of iterations to show a progress report every so often",
                "short": "Update interval",
                "type": "int",
                "min": 1,
                "default": 100
            },
            "step_size": {
                "help": "Step sizes for the problem variables. It can be given in various lengths that are extended to the correct size.",
                "short": "Step sizes",
                "type": "list",
                "subtype": "float",
                "min": 0.0,
                "default": [0.25, 0.025]
            }
        }
    },
    "planning_problem": {
        "name": "Reconstruction trajectory planning problem",
        "settings": {
            "number_of_measurements": {
                "help": "Maximum number of measurements to perform",
                "short": "Measurements",
                "type": "int",
                "min": 1,
                "default": 100
            },
            "network_size": {
                "help": "Dimensions of the total space wherein the network lies, in number of grid cells",
                "short": "Network size",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "default": [10, 10]
            },
            "network_padding": {
                "help": "Number of full cells for each dimension and on every side where the vehicles are allowed to drive around the network",
                "short": "Padding",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [0, 0]
            },
            "unsnappable_rate": {
                "help": "Ratio of the number of measurements that are allowed to be useless in the reconstruction problem and thus are discarded",
                "short": "Unsnappable rate",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.5
            },
            "delta_rate": {
                "help": "Ratio between sensor distances and mission length. A higher value gives the sensor distances more weight in the objective, a lower value gives the travel distance more weight.",
                "short": "Delta",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.5
            }
        }
    },
    "planning_assignment": {
        "name": "Planning waypoint assignment problem",
        "settings": {
            "vehicle_home_locations": {
                "help": "Home location coordinates for the vehicles",
                "short": "Home locations",
                "type": "list",
                "subtype": {
                    "type": "tuple",
                    "length": 2,
                    "subtype": "int"
                },
                "default": [[0, 0], [0, 9]]
            }
        }
    },
    "reconstruction": {
        "name": "Reconstruction",
        "settings": {
            "cmap": {
                "help": "Color map for the reconstruction display. It must be a valid matplotlib colormap.",
                "short": "Color map",
                "type": "string",
                "required": true,
                "keys": ["matplotlib.cm", "datad"],
                "default": "gist_heat_r"
            },
            "percentiles": {
                "help": "Percentiles for the reconstruction display. They are used to smoothen the image by suppressing pixel values that do not correspond to high attenuation.",
                "short": "Percentiles",
                "type": "list",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [2, 10]
            },
            "interpolation": {
                "help": "Pixel interpolation for the reconstruction display",
                "short": "Interpolation",
                "type": "string",
                "required": false,
                "keys": ["matplotlib.image", "AxesImage", "_interpd"],
                "default": "hamming"
            },
            "chunk_size": {
                "help": "Number of measurements to obtain before rendering a new image",
                "short": "Chunk size",
                "type": "int",
                "min": 1,
                "default": 50
            },
            "reconstructor": {
                "help": "Reconstruction algorithm to use",
                "short": "Reconstructor",
                "type": "class",
                "module": "reconstruction.Reconstructor",
                "replace": [" ", "_"],
                "default": "Total_Variation_Reconstructor"
            }
        }
    },
    "reconstruction_dataset": {
        "name": "Reconstruction (dataset source)",
        "parent": "reconstruction",
        "settings": {
            "dataset_calibration_file": {
                "help": "Filename part to use for dataset reconstruction calibration",
                "short": "Calibration file",
                "type": "file",
                "format": "assets/dataset_{}.csv",
                "full_name": true,
                "required": false,
                "default": "empty"
            },
            "dataset_file": {
                "help": "Filename part to use for dataset reconstruction",
                "short": "Dataset file",
                "type": "file",
                "format": "assets/dataset_{}.csv",
                "full_name": true,
                "required": false,
                "default": "one_person_moving_square"
            }
        }
    },
    "reconstruction_dump": {
        "name": "Reconstruction (dump source)",
        "parent": "reconstruction",
        "settings": {
            "dump_calibration_file": {
                "help": "Filename part to use for dump reconstruction calibration",
                "short": "Calibration file",
                "type": "file",
                "format": "assets/dump_{}.json",
                "full_name": true,
                "required": false,
                "default": "empty"
            },
            "dump_file": {
                "help": "Filename part to use for dump reconstruction",
                "short": "Dump file",
                "type": "file",
                "format": "assets/dump_{}.json",
                "full_name": true,
                "required": false,
                "default": "static_manual"
            }
        }
    },
    "reconstruction_stream": {
        "name": "Reconstruction (stream source)",
        "parent": "reconstruction",
        "settings": {
            "stream_network_size": {
                "help": "The size of the network, in pixels of the resulting image (zero-based)",
                "short": "Network size",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "default": [9, 9]
            },
            "stream_network_origin": {
                "help": "The distance of the network from the origin",
                "short": "Origin",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "default": [0, 0]
            },
            "stream_record": {
                "help": "Whether to record the received packets for saving afterward",
                "short": "Record",
                "type": "bool",
                "default": false
            },
            "stream_calibrate": {
                "help": "Whether to assume that the current mission is a calibration. If disabled, then the calibration file is used.",
                "short": "Calibrate mode",
                "type": "bool",
                "default": false
            },
            "stream_calibration_file": {
                "help": "Calibration file to use for initial calibration",
                "short": "Calibration file",
                "type": "file",
                "format": "assets/stream_{}.json",
                "full_name": true,
                "required": false,
                "default": null
            }
        }
    },
    "reconstruction_weight_matrix": {
        "name": "Reconstruction (weight matrix)",
        "settings": {
            "distance_lambda": {
                "help": "Width of an ellipse in the measurement model",
                "type": "float",
                "min": 0.0,
                "default": 0.3
            }
        }
    },
    "reconstruction_total_variation": {
        "name": "Reconstruction (total variation)",
        "settings": {
            "alpha": {
                "help": "Factor that determines the importance of a smooth solution",
                "short": "Alpha",
                "type": "float",
                "min": 0,
                "max": 1,
                "default": 0.4
            },
            "beta": {
                "help": "Factor that determines the sharpness of the solution",
                "short": "Beta",
                "type": "float",
                "min": 0,
                "default": 0.001
            },
            "solver_method": {
                "help": "Minimization method to use by the solver",
                "short": "Solver method",
                "type": "string",
                "required": true,
                "default": "L-BFGS-B"
            },
            "solver_iterations": {
                "help": "Maximum number of iterations for the solver",
                "short": "Solver iterations",
                "type": "int",
                "min": 1,
                "default": 20
            }
        }
    },
    "reconstruction_truncated_svd": {
        "name": "Reconstruction (truncated SVD)",
        "settings": {
            "singular_values": {
                "help": "Number of singular values to compute",
                "short": "Singular values",
                "type": "int",
                "min": 1,
                "default": 30
            }
        }
    },
    "zigbee_base": {
        "name": "ZigBee base",
        "settings": {
            "number_of_sensors": {
                "help": "Number of vehicle sensors in the network, not counting the ground station",
                "type": "int",
                "min": 0,
                "default": 2
            },
            "rf_sensor_id": {
                "help": "Identifier for the current RF sensor (overridden by the physical sensor)",
                "type": "int",
                "min": 0,
                "default": 0
            },
            "custom_packet_delay": {
                "help": "Delay in seconds between sending custom packets when not measuring",
                "type": "float",
                "min": 0.0,
                "default": 0.1
            },
            "loop_delay": {
                "help": "Delay in seconds for each sensor loop",
                "type": "float",
                "min": 0.0,
                "default": 0.01
            },
            "startup_delay": {
                "help": "Delay in seconds to wait after initializing the sensor",
                "type": "float",
                "min": 0.0,
                "default": 1.0
            }
        }
    },
    "xbee_configurator": {
        "name": "XBee configurator",
        "parent": "zigbee_base",
        "settings": {
            "pan_id": {
                "help": "Personal area network identifier",
                "type": "int",
                "min": 0,
                "max": 65535,
                "default": 2015
            }
        }
    },
    "xbee_sensor_simulator": {
        "name": "XBee sensor (simulator)",
        "parent": "zigbee_base",
        "settings": {
            "ip": {
                "help": "IP address to connect the socket to",
                "type": "string",
                "required": false,
                "default": "127.0.0.1"
            },
            "socket_port": {
                "help": "Network port to connect the socket to",
                "type": "int",
                "min": 0,
                "max": 65535,
                "default": 3233
            },
            "buffer_size": {
                "help": "Size of the buffer to read at most from the socket each time",
                "type": "int",
                "min": 1,
                "default": 256
            }
        }
    },
    "xbee_sensor_physical": {
        "name": "XBee sensor (physical)",
        "parent": "zigbee_base",
        "settings": {
            "port": {
                "help": "Device name or port of the XBee to use. This overrides the USB manager detection.",
                "type": "string",
                "required": false,
                "default": ""
            },
            "sensors": {
                "help": "XBee addresses of all devices in the network, ordered by their identifier",
                "type": "list",
                "subtype": "string",
                "default": [
                    "\\x00\\x13\\xa2\\x00@\\xe6n\\xbd",
                    "\\x00\\x13\\xa2\\x00@\\xe6o5",
                    "\\x00\\x13\\xa2\\x00@\\xe6n\\xb9"
                ]
            },
            "ntp_delay": {
                "help": "Delay in seconds to wait before retrying a synchronization attempt",
                "type": "float",
                "min": 0.0,
                "default": 3.0
            },
            "response_delay": {
                "help": "Delay in seconds to wait for a response to a command sent to the current XBee device",
                "type": "float",
                "min": 0.0,
                "default": 0.3
            },
            "synchronize": {
                "help": "Whether to synchronize the clock using the NTP algorithm, which is required for TDMA scheduling to work correctly. The program must run as root to do so.",
                "type": "bool",
                "default": false
            }
        }
    },
    "xbee_cc2530_sensor_physical": {
        "name": "XBee CC2530 sensor (physical)",
        "parent": "xbee_sensor_physical",
        "settings": {
            "packet_length": {
                "help": "Number of bytes in the serialized packet",
                "type": "int",
                "min": 0,
                "max": 255,
                "default": 80
            },
            "reset_delay": {
                "help": "Delay in seconds before changing the reset pulse",
                "type": "float",
                "min": 0.01,
                "default": 0.02
            },
            "rx_pin": {
                "help": "Raspberry Pi GPIO pin for UART RX",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 10
            },
            "tx_pin": {
                "help": "Raspberry Pi GPIO pin for UART TX",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 8
            },
            "rts_pin": {
                "help": "Raspberry Pi GPIO pin for UART RTS",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 11
            },
            "cts_pin": {
                "help": "Raspberry Pi GPIO pin for UART CTS",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 36
            },
            "reset_pin": {
                "help": "Raspberry Pi GPIO pin for resetting the sensor",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 40
            }
        }
    },
    "zigbee_tdma_scheduler": {
        "name": "ZigBee TDMA scheduler",
        "parent": "zigbee_base",
        "settings": {
            "sweep_delay": {
                "help": "Delay in seconds for each sweep",
                "type": "float",
                "min": 0.0,
                "default": 0.4
            }
        }
    },
    "test_runner": {
        "name": "Test runner",
        "settings": {
            "pattern": {
                "help": "Shell-style pattern that determines tests to run. Only tests in files that match are included.",
                "type": "string",
                "default": "*.py"
            },
            "verbosity": {
                "help": "Level of verboseness of the test runner",
                "type": "int",
                "min": 0,
                "default": 1
            },
            "coverage": {
                "help": "Provide a code coverage report",
                "type": "bool",
                "default": true
            },
            "default_branch": {
                "help": "Git branch that is the default from which other branches fork",
                "type": "string",
                "default": "master"
            },
            "profile_sort": {
                "help": "Sort method to use for the profile statistics",
                "type": "string",
                "keys": ["pstats", "Stats", "sort_arg_dict_default"],
                "default": "tottime"
            },
            "profile_limit": {
                "help": "Maximum number of items to show from the profile statistics",
                "type": "int",
                "min": 0,
                "default": 7
            }
        }
    }
}
