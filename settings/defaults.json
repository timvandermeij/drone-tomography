{
    "control_panel": {
        "name": "Control panel",
        "settings": {
            "core_rf_sensor_class": {
                "help": "RF sensor class to use for the control panel",
                "type": "class",
                "module": "zigbee.RF_Sensor",
                "required": true,
                "replace": [" ", "_"],
                "default": "RF_Sensor_Physical_Texas_Instruments"
            }
        }
    },
    "control_panel_loading": {
        "name": "Control panel (loading view)",
        "settings": {
            "loading_insertion_delay": {
                "help": "Frequency in seconds to check for a newly inserted RF sensor",
                "type": "float",
                "min": 0.0,
                "default": 0.1
            }
        }
    },
    "control_panel_devices": {
        "name": "Control panel (devices view)",
        "settings": {
            "devices_discover_delay": {
                "help": "Frequency in seconds to handle a discovered RF sensor",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            }
        }
    },
    "control_panel_planning": {
        "name": "Control panel (planning view)",
        "parent": "planning",
        "settings": {
            "planning_update_interval": {
                "help": "Frequency in seconds to handle planning algorithm updates. This depends on the `iteration_callback` setting and the speed of the algorithm run.",
                "type": "float",
                "min": 0.0,
                "default": 0.2
            },
            "planning_plot_dimensions": {
                "help": "Size in pixels for the width and height, respectively, of the Pareto front viewer",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [550, 550]
            }
        }
    },
    "control_panel_reconstruction": {
        "name": "Control panel (reconstruction view)",
        "parent": "reconstruction",
        "settings": {
            "reconstruction_curve_points": {
                "help": "Number of points to show on a plotted curve",
                "type": "int",
                "min": 5,
                "default": 20
            },
            "reconstruction_grid_size": {
                "help": "Maximum width and height of the grid view in pixels",
                "type": "int",
                "min": 100,
                "default": 350
            },
            "reconstruction_pause_time": {
                "help": "Delay in seconds to wait before entering the next reconstruction loop iteration",
                "short": "Pause time",
                "type": "float",
                "min": 0.0,
                "default": 0.02
            },
            "reconstruction_table_limit": {
                "help": "Maximum number of rows in the measurements table",
                "type": "int",
                "min": 1,
                "default": 1000
            }
        }
    },
    "control_panel_settings": {
        "name": "Control panel (settings view)",
        "settings": {
            "settings_max_retries": {
                "help": "Number of retries for every setting packet sent to a vehicle",
                "type": "int",
                "min": 1,
                "default": 5
            },
            "settings_retry_interval": {
                "help": "Frequency in seconds to retry sending a setting packet to a vehicle",
                "type": "float",
                "min": 0.0,
                "default": 0.15
            }
        }
    },
    "control_panel_waypoints": {
        "name": "Control panel (waypoints view)",
        "settings": {
            "waypoints_max_retries": {
                "help": "Number of retries for every waypoint packet sent to a vehicle",
                "type": "int",
                "min": 1,
                "default": 5
            },
            "waypoints_retry_interval": {
                "help": "Frequency in seconds to retry sending a waypoint packet to a vehicle",
                "type": "float",
                "min": 0.0,
                "default": 0.15
            }
        }
    },
    "distance_sensor_simulator": {
        "name": "Distance sensor (simulator)",
        "settings": {
            "altitude_margin": {
                "help": "Difference in altitude in meters at which simple objects are still visible",
                "type": "float",
                "min": 0.0,
                "default": 2.5
            },
            "angle_margin": {
                "help": "Difference in angle in degrees at which simple objects are still visible",
                "type": "float",
                "min": 0.0,
                "default": 5.0
            },
            "maximum_distance": {
                "help": "Maximum distance in meters at which an object is still visible",
                "type": "float",
                "min": 0.0,
                "default": 1000.0
            }
        }
    },
    "distance_sensor_physical": {
        "name": "Distance sensor (physical)",
        "settings": {
            "trigger_pin": {
                "help": "GPIO board pin to use for the HC-SR04 trigger pin",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 13
            },
            "echo_pin": {
                "help": "GPIO board pin to use for the HC-SR04 echo pin",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 11
            },
            "trigger_delay": {
                "help": "Time in seconds to wait for the trigger pin to become active",
                "type": "float",
                "min": 0.0,
                "default": 0.00001
            },
            "interval_delay": {
                "help": "Time in seconds to wait after making the pins ready for measurements",
                "type": "float",
                "min": 0.0,
                "default": 0.5
            },
            "speed_of_sound": {
                "help": "Speed of sound in cm/s",
                "type": "float",
                "min": 0,
                "default": 34320
            }
        }
    },
    "infrared_sensor": {
        "name": "Infrared sensor",
        "settings": {
            "remote": {
                "help": "Remote control configuration name. The program must run as root if a new remote is used.",
                "type": "file",
                "required": true,
                "format": "control/remotes/{}.lircrc",
                "default": "Sony_RM-SRB5"
            },
            "program": {
                "help": "Program name",
                "type": "string",
                "required": true,
                "default": "mobile-radio-tomography"
            },
            "buttons": {
                "help": "Registered buttons",
                "type": "list",
                "subtype": "string",
                "default": ["start", "pause", "stop", "up", "down", "left", "right", "poweroff"]
            },
            "wait_delay": {
                "help": "Delay in seconds for the infrared sensor thread",
                "type": "float",
                "min": 0.0,
                "default": 0.05
            }
        }
    },
    "line_follower_base": {
        "name": "Line follower base",
        "settings": {
            "readable_leds": {
                "help": "LED list indices to be used by the line follower",
                "type": "list",
                "length": 4,
                "subtype": "int",
                "min": 0,
                "default": [0, 2, 3, 5]
            },
            "line_threshold": {
                "help": "Threshold in microseconds above which a LED measurement is considered black",
                "type": "int",
                "min": 0,
                "default": 300
            }
        }
    },
    "line_follower_raspberry_pi": {
        "name": "Line follower (Raspberry Pi)",
        "parent": "line_follower_base",
        "settings": {
            "led_pins": {
                "help": "Raspberry Pi GPIO pins for the measurement LEDs",
                "type": "list",
                "subtype": "int",
                "min": 1,
                "default": [29, 31, 32, 33, 35, 36]
            },
            "emitter_pin": {
                "help": "Raspberry Pi GPIO pin for the emitter signal",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 37
            },
            "write_delay": {
                "help": "Delay in seconds to wait after changing the emitter signal",
                "type": "float",
                "min": 0.0,
                "default": 0.0002
            },
            "max_value": {
                "help": "Maximum value read from the line follower in microseconds",
                "type": "int",
                "min": 0,
                "default": 1023
            },
            "charge_delay": {
                "help": "Delay in seconds to wait after charging the measurement pins",
                "type": "float",
                "min": 0.0,
                "default": 0.00001
            }
        }
    },
    "line_follower_arduino": {
        "name": "Line follower (Arduino)",
        "parent": "line_follower_base",
        "settings": {}
    },
    "mission": {
        "name": "Drone trajectory mission data",
        "settings": {
            "altitude_undershoot": {
                "help": "Ratio of requested altitude which is allowed for takeoff altitude",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.95
            },
            "closeness": {
                "help": "Difference in meters at which we consider locations to be equal for waypoints, too close to detected objects, or in other mission movements. Set to 0 to disable.",
                "type": "float",
                "min": 0.0,
                "default": 2.0
            },
            "farness": {
                "help": "Distance in meters above which we are uninterested in detected objects",
                "type": "float",
                "min": 0.0,
                "default": 100.0
            },
            "mission_delay": {
                "help": "Delay in seconds to ensure that vehicle mission information is displayed cleanly",
                "type": "float",
                "min": 0.0,
                "default": 2.0
            },
            "altitude": {
                "help": "Altitude in meters to take off to. Ignored for ground vehicles.",
                "type": "float",
                "default": 4.0
            },
            "padding": {
                "help": "The space around the vehicle's center (where the distance sensor is) in which we do not want to have other objects. Used for additional padding aside from the closeness in certain calculations.",
                "type": "float",
                "min": 0.0,
                "default": 4.0
            },
            "speed": {
                "help": "Movement speed in m/s",
                "type": "float",
                "min": 0.0,
                "default": 2.5
            },
            "space_size": {
                "help": "Size in meters of one dimension of the part of the space that the vehicle is allowed to be in",
                "type": "float",
                "min": 0.0,
                "default": 20.0
            },
            "resolution": {
                "help": "The number of entries in the memory map per meter in one dimension",
                "type": "int",
                "min": 1,
                "default": 1
            },
            "yaw_step": {
                "help": "Difference of angle in degrees to change the yaw with in steps of some missions",
                "type": "float",
                "default": 10.0
            },
            "mission_class": {
                "help": "Mission class to use for the mission",
                "type": "class",
                "module": "mission",
                "default": "Mission_RF_Sensor"
            },
            "rf_sensor_synchronization": {
                "help": "Whether to wait for measurements to be complete at waypoints",
                "type": "bool",
                "default": true
            },
            "mission_dump_file": {
                "help": "File to store dumps of missions in",
                "type": "file",
                "default": "mission_dump.json"
            }
        }
    },
    "mission_monitor": {
        "name": "Mission monitoring",
        "settings": {
            "step_delay": {
                "help": "Delay in seconds to wait before monitoring again",
                "type": "float",
                "min": 0.0,
                "default": 0.3
            },
            "plot": {
                "help": "Whether to display an interactive plot of the memory map (requires matplotlib)",
                "type": "bool",
                "default": true
            },
            "viewer": {
                "help": "Whether to display a viewer of the current vehicle's sight (requires pyglet and a simulated environment)",
                "type": "bool",
                "default": true
            },
            "plot_sensor_colors": {
                "help": "Color names to use for the selected edges by different sensors in the memory map plot during simulation",
                "type": "list",
                "subtype": "string",
                "default": ["red", "purple", "black"]
            }
        }
    },
    "environment": {
        "name": "Vehicle environment",
        "settings": {
            "geometry_class": {
                "help": "Geometry to use for location calculations",
                "type": "class",
                "module": "geometry",
                "default": "Geometry_Spherical"
            },
            "distance_sensors": {
                "help": "Yaw angle in degrees for each distance sensor",
                "type": "list",
                "subtype": "float",
                "default": [0.0]
            },
            "servo_pins": {
                "help": "Servo pin number and duty cycle ranges for the servo rail.\nEach item contains the following keys and values:\n- 'pin': a pin number of the servo rail or GPIO port\n- 'angles': a tuple of minimum and maximum angles in degrees that the servo can turn to\n- 'pwm': a tuple of minimum and maximum PWM values (duty cycle)",
                "type": "list",
                "subtype": "dict",
                "dictinfo": {
                    "pin": {
                        "type": "int",
                        "min": 1,
                        "max": 40
                    },
                    "angles": {
                        "type": "tuple",
                        "length": 2,
                        "subtype": "int",
                        "min": 0,
                        "max": 360
                    },
                    "pwm": {
                        "type": "tuple",
                        "length": 2,
                        "subtype": "int"
                    }
                },
                "default": [
                    {
                        "pin": 7,
                        "angles": [0,360],
                        "pwm": [1000,2000]
                    }
                ]
            },
            "rf_sensor_class": {
                "help": "RF sensor class to use for the environment",
                "type": "class",
                "module": "zigbee.RF_Sensor",
                "required": false,
                "replace": [" ", "_"],
                "default": ""
            },
            "infrared_sensor": {
                "help": "Whether to use the infrared sensor for starting and stopping a mission",
                "type": "bool",
                "default": true
            },
            "scenefile": {
                "help": "VRML file to import as simulated environment",
                "type": "file",
                "format": "tests/vrml/{}.wrl",
                "required": false,
                "default": null
            },
            "translation": {
                "help": "Differences in meters to offset the simulated environment with",
                "type": "tuple",
                "length": 3,
                "subtype": "float",
                "default": [0.0,0.0,0.0]
            },
            "location_check": {
                "help": "Whether to enable collision checks in a simulated environment",
                "type": "bool",
                "default": false
            }
        }
    },
    "environment_viewer": {
        "name": "Environment 3D scene viewer",
        "settings": {
            "max_points": {
                "help": "Maximum number of recently detected points to keep in the viewer",
                "type": "int",
                "min": 0,
                "default": 200
            }
        }
    },
    "environment_viewer_interactive": {
        "name": "Interactive environment 3D scene viewer",
        "parent": "environment_viewer",
        "settings": {
            "camera_move_speed": {
                "help": "Speed in m/s to move the camera while strafing. Negative value causes inverted controls.",
                "type": "float",
                "default": 5.0
            },
            "camera_rotate_speed": {
                "help": "Speed in degrees/s to rotate the camera. Negative value causes inverted controls.",
                "type": "float",
                "default": 90.0
            }
        }
    },
    "vehicle": {
        "name": "Vehicle interface",
        "settings": {
            "vehicle_class": {
                "help": "Vehicle backend to use",
                "type": "class",
                "module": "vehicle",
                "default": "Mock_Vehicle"
            }
        }
    },
    "vehicle_dronekit": {
        "name": "Dronekit vehicle backend",
        "settings": {
            "connect": {
                "help": "MAVLink connection string to the autopilot master",
                "type": "string",
                "default": "127.0.0.1:14550"
            },
            "mavlink_baud_rate": {
                "help": "Baud rate for the MAVLink connection",
                "type": "int",
                "min": 0,
                "default": 115200
            },
            "vehicle_simulation": {
                "help": "Whether to run the vehicle in a simulator rather than a physical environment",
                "type": "bool",
                "default": true
            },
            "gps": {
                "help": "Whether to wait for a GPS signal before starting",
                "type": "bool",
                "default": true
            }
        }
    },
    "vehicle_robot": {
        "name": "Base robot vehicle",
        "settings": {
            "diverged_speed": {
                "help": "Ratio of the current move speed to adapt when the vehicle diverges from a line",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.25
            },
            "diverged_time": {
                "help": "Time in seconds to keep adjusted speed when the vehicle diverges from a line",
                "type": "float",
                "min": 0.0,
                "default": 0.2
            },
            "rotate_speed": {
                "help": "Speed in m/s to use when the vehicle rotates on an intersection",
                "type": "float",
                "min": 0.0,
                "default": 0.30
            },
            "vehicle_delay": {
                "help": "Delay in seconds of the robot vehicle state loop",
                "type": "float",
                "min": 0.0,
                "default": 0.05
            },
            "line_follower_delay": {
                "help": "Delay of the sensor reading loop in the line follower thread",
                "type": "float",
                "min": 0.0,
                "default": 0.01
            },
            "home_location": {
                "help": "Home location coordinates of the vehicle. The vehicle should be placed at the intersection corresponding to these coordinates to begin with.",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [0, 0]
            },
            "home_direction": {
                "help": "The starting direction of the robot. The robot should be aligned with this direction to begin with. 0 is up, 1 is right, 2 is down and 3 is left.",
                "type": "enum",
                "enum": ["location.Line_Follower", "Line_Follower_Direction"],
                "default": 0
            },
            "vehicle_network_origin": {
                "help": "Origin of the area where the vehicle is not allowed to be inside, starting with eastward coordinate, then northward coordinate",
                "type": "tuple",
                "subtype": "float",
                "length": 2,
                "default": [1, 1]
            },
            "vehicle_network_size": {
                "help": "Width and height of the area where the vehicle is not allowed to be inside",
                "type": "tuple",
                "subtype": "float",
                "length": 2,
                "default": [19, 19]
            }
        }
    },
    "vehicle_robot_raspberry_pi": {
        "name": "Robot vehicle directly connected to a Raspberry Pi",
        "settings": {
            "direction_pins": {
                "help": "Motor direction GPIO pins",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "max": 40,
                "default": [16, 18]
            },
            "motor_speed_pins": {
                "help": "Motor speed GPIO pins",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "max": 40,
                "default": [24, 26]
            },
            "motor_speed_pwms": {
                "help": "PWM range for both motors (minimum and maximum value)",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [0, 255]
            },
            "motor_speeds": {
                "help": "Speed range for both motors in m/s",
                "type": "tuple",
                "length": 2,
                "subtype": "float",
                "min": 0.0,
                "default": [0, 0.60]
            }
        }
    },
    "vehicle_robot_arduino": {
        "name": "Robot vehicle connected through an Arduino with a serial connection",
        "settings": {
            "activate_delay": {
                "help": "Number of seconds to wait for the Arduino to restart during activation",
                "type": "float",
                "default": 1.75
            },
            "motor_speed_pwms": {
                "help": "PWM range for both motors (minimum and maximum values)",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "default": [-400, 400]
            },
            "motor_speeds": {
                "help": "Speed range for both motors in m/s",
                "type": "tuple",
                "length": 2,
                "subtype": "float",
                "default": [-0.60, 0.60]
            }
        }
    },
    "planning": {
        "name": "Planning problem",
        "settings": {
            "network_size": {
                "help": "Dimensions of the total space wherein the network lies, in number of grid cells, including the padding. First dimension is north, second is east.",
                "short": "Network size",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "default": [19, 19]
            },
            "network_padding": {
                "help": "Number of full cells for each dimension and on every side where the vehicles are allowed to drive around the network. First dimension is north, second is east.",
                "short": "Padding",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [1, 1]
            }
        }
    },
    "planning_runner": {
        "name": "Planning problem: supervisor",
        "parent": "planning",
        "settings": {
            "algorithm_class": {
                "help": "The evolutionary algorithm to use for the planning problem. It can be given with dashes instead of underscores and with lowercase letters.",
                "short": "Algorithm",
                "type": "class",
                "module": "planning.Algorithm",
                "replace": ["-", "_"],
                "default": "NSGA"
            },
            "discrete": {
                "help": "Whether to use discrete grid cells instead of allowing measurements to happen anywhere",
                "short": "Discrete",
                "type": "bool",
                "default": true
            }
        }
    },
    "planning_algorithm": {
        "name": "Planning problem: evolutionary multiobjective optimization",
        "settings": {
            "population_size": {
                "help": "Number of individuals to use during optimization. Afterward, at most this number of nondominated solutions is presented.",
                "short": "Population",
                "type": "int",
                "min": 1,
                "default": 15
            },
            "iteration_limit": {
                "help": "Number of iterations to run optimization for",
                "short": "Iterations",
                "type": "int",
                "min": 0,
                "default": 2000
            },
            "iteration_callback": {
                "help": "Number of iterations to show a progress report every so often",
                "short": "Update interval",
                "type": "int",
                "min": 1,
                "default": 100
            },
            "step_size": {
                "help": "Step sizes for the problem variables. It can be given in various lengths that are extended to the correct size.",
                "short": "Step sizes",
                "type": "list",
                "subtype": "float",
                "min": 0.0,
                "default": [0.25, 0.025]
            }
        }
    },
    "planning_problem": {
        "name": "Planning problem: trajectory reconstruction specifications",
        "parent": "planning",
        "settings": {
            "number_of_measurements": {
                "help": "Maximum number of measurements to perform",
                "short": "Measurements",
                "type": "int",
                "min": 1,
                "default": 350
            },
            "unsnappable_rate": {
                "help": "Ratio of the number of measurements that are allowed to be useless in the reconstruction problem and thus are discarded",
                "short": "Unsnappable rate",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.75
            },
            "delta_rate": {
                "help": "Ratio between sensor distances and mission length. A higher value gives the sensor distances more weight in the objective, a lower value gives the travel distance more weight.",
                "short": "Delta",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.8
            },
            "mutation_operator": {
                "help": "Whether to use a specialized mutation operator during the discrete problem",
                "short": "Mutation operator",
                "type": "bool",
                "default": false
            }
        }
    },
    "planning_assignment": {
        "name": "Planning problem: waypoint assignment",
        "settings": {
            "vehicle_home_locations": {
                "help": "Home location coordinates for the vehicles",
                "short": "Home locations",
                "type": "list",
                "subtype": {
                    "type": "tuple",
                    "length": 2,
                    "subtype": "int"
                },
                "default": [[0, 0], [0, 19], [19, 0], [19, 19]]
            },
            "vehicle_home_directions": {
                "help": "Home directions for the vehicles. 0 is up, 1 is right, 2 is down and 3 is left.",
                "short": "Home directions",
                "type": "list",
                "subtype": {
                    "type": "enum",
                    "enum": ["location.Line_Follower", "Line_Follower_Direction"]
                },
                "default": [0, 0, 2, 2]
            },
            "turning_cost": {
                "help": "Additional distance compared to the norm distance for turning a vehicle",
                "short": "Turning cost",
                "type": "float",
                "min": 0.0,
                "default": 1.0
            }
        }
    },
    "planning_collision_avoidance": {
        "name": "Planning problem: vehicle collision avoidance",
        "parent": "planning",
        "settings": {
            "collision_avoidance": {
                "help": "Whether to enable the collision avoidance algorithm",
                "short": "Collision avoidance",
                "type": "bool",
                "default": false
            },
            "unsafe_path_cost": {
                "help": "Additional distance compared to the norm distance when there is no safe path possible to a certain waypoint. This should account for lost distance due to halting and detours. If this is 'inf', then the solution is considered infeasible.",
                "short": "Unsafe path cost",
                "type": "float",
                "inf": true,
                "min": 0.0,
                "default": Infinity
            },
            "assign_safe_path": {
                "help": "Whether to use safe paths found by the collision avoidance algorithm in the assignment",
                "short": "Assign safe paths",
                "type": "bool",
                "default": false
            }
        }
    },
    "reconstruction": {
        "name": "Reconstruction",
        "settings": {
            "cmap": {
                "help": "Color map for the reconstruction display. It must be a valid matplotlib colormap.",
                "short": "Color map",
                "type": "string",
                "required": true,
                "keys": ["matplotlib.cm", "datad"],
                "default": "gist_heat_r"
            },
            "percentiles": {
                "help": "Percentiles for the reconstruction display. They are used to smoothen the image by suppressing pixel values that do not correspond to high attenuation.",
                "short": "Percentiles",
                "type": "list",
                "length": 2,
                "subtype": "int",
                "min": 0,
                "default": [1, 5]
            },
            "interpolation": {
                "help": "Pixel interpolation for the reconstruction display",
                "short": "Interpolation",
                "type": "string",
                "required": false,
                "keys": ["matplotlib.image", "AxesImage", "_interpd"],
                "default": "none"
            },
            "chunk_size": {
                "help": "Number of measurements to obtain before rendering a new image",
                "short": "Chunk size",
                "type": "int",
                "min": 1,
                "default": 10
            },
            "reconstructor_class": {
                "help": "Reconstruction algorithm to use",
                "short": "Reconstructor",
                "type": "class",
                "module": "reconstruction.Reconstructor",
                "replace": [" ", "_"],
                "default": "Total_Variation_Reconstructor"
            },
            "model_class": {
                "help": "Model class to use for the weight matrix",
                "short": "Model",
                "type": "class",
                "module": "reconstruction.Model",
                "required": true,
                "replace": [" ", "_"],
                "default": "Gaussian_Model"
            }
        }
    },
    "reconstruction_dataset": {
        "name": "Reconstruction (dataset source)",
        "parent": "reconstruction",
        "settings": {
            "dataset_calibration_file": {
                "help": "Filename part to use for dataset reconstruction calibration",
                "short": "Calibration file",
                "type": "file",
                "format": "assets/dataset_{}.csv",
                "full_name": true,
                "required": false,
                "default": "assets/dataset_empty.csv"
            },
            "dataset_file": {
                "help": "Filename part to use for dataset reconstruction",
                "short": "Dataset file",
                "type": "file",
                "format": "assets/dataset_{}.csv",
                "full_name": true,
                "required": false,
                "default": "assets/dataset_one_person_moving_square.csv"
            }
        }
    },
    "reconstruction_dump": {
        "name": "Reconstruction (dump source)",
        "parent": "reconstruction",
        "settings": {
            "dump_calibration_file": {
                "help": "Filename part to use for dump reconstruction calibration",
                "short": "Calibration file",
                "type": "file",
                "format": "assets/dump_{}.json",
                "full_name": true,
                "required": false,
                "default": "assets/dump_empty.json"
            },
            "dump_file": {
                "help": "Filename part to use for dump reconstruction",
                "short": "Dump file",
                "type": "file",
                "format": "assets/dump_{}.json",
                "full_name": true,
                "required": false,
                "default": "assets/dump_two_persons_standing.json"
            }
        }
    },
    "reconstruction_stream": {
        "name": "Reconstruction (stream source)",
        "parent": "reconstruction",
        "settings": {
            "stream_network_size": {
                "help": "The size of the network, in pixels of the resulting image (zero-based)",
                "short": "Network size",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "min": 1,
                "default": [19, 19]
            },
            "stream_network_origin": {
                "help": "The distance of the network from the origin",
                "short": "Origin",
                "type": "tuple",
                "length": 2,
                "subtype": "int",
                "default": [0, 0]
            },
            "stream_record": {
                "help": "Whether to record the received packets for saving afterward",
                "short": "Record",
                "type": "bool",
                "default": false
            },
            "stream_calibrate": {
                "help": "Whether to assume that the current mission is a calibration. If disabled, then the calibration file is used.",
                "short": "Calibrate mode",
                "type": "bool",
                "default": false
            },
            "stream_calibration_file": {
                "help": "Calibration file to use for initial calibration",
                "short": "Calibration file",
                "type": "file",
                "format": "assets/stream_{}.json",
                "full_name": true,
                "required": false,
                "default": null
            }
        }
    },
    "reconstruction_ellipse_model": {
        "name": "Reconstruction (ellipse model)",
        "settings": {
            "lambda": {
                "help": "Minor axis diameter of the ellipse used in the model",
                "short": "Lambda",
                "type": "float",
                "min": 0.0,
                "default": 0.3
            }
        }
    },
    "reconstruction_gaussian_model": {
        "name": "Reconstruction (Gaussian model)",
        "settings": {
            "sigma": {
                "help": "Standard deviation of the Gaussian function that determines the width of the curve's top",
                "short": "Sigma",
                "type": "float",
                "min": 0.0,
                "default": 0.3
            }
        }
    },
    "reconstruction_line_model": {
        "name": "Reconstruction (line model)",
        "settings": {
            "threshold": {
                "help": "Maximum difference from the link length for determining that a pixel is on the line-of-sight path",
                "short": "Threshold",
                "type": "float",
                "min": 0.0,
                "default": 0.34
            }
        }
    },
    "reconstruction_iterative_reconstructor": {
        "name": "Reconstruction (iterative reconstructor)",
        "settings": {
            "alpha": {
                "help": "Importance of the additional factor",
                "short": "Alpha",
                "type": "float",
                "min": 0,
                "max": 1,
                "default": 0.4
            },
            "solver_method": {
                "help": "Minimization method to use by the solver",
                "short": "Solver method",
                "type": "string",
                "required": true,
                "default": "SLSQP"
            },
            "solver_iterations": {
                "help": "Maximum number of iterations for the solver",
                "short": "Solver iterations",
                "type": "int",
                "min": 1,
                "default": 1
            }
        }
    },
    "reconstruction_maximum_entropy_reconstructor": {
        "name": "Reconstruction (maximum entropy)",
        "parent": "reconstruction_iterative_reconstructor",
        "settings": {}
    },
    "reconstruction_total_variation_reconstructor": {
        "name": "Reconstruction (total variation)",
        "parent": "reconstruction_iterative_reconstructor",
        "settings": {
            "beta": {
                "help": "Factor that determines the sharpness of the solution",
                "short": "Beta",
                "type": "float",
                "min": 0,
                "default": 0.001
            }
        }
    },
    "reconstruction_truncated_svd_reconstructor": {
        "name": "Reconstruction (truncated SVD)",
        "settings": {
            "singular_values": {
                "help": "Number of singular values to compute",
                "short": "Singular values",
                "type": "int",
                "min": 1,
                "default": 30
            }
        }
    },
    "zigbee_base": {
        "name": "ZigBee base",
        "settings": {
            "number_of_sensors": {
                "help": "Number of vehicle sensors in the network, not counting the ground station",
                "type": "int",
                "min": 0,
                "default": 4
            },
            "rf_sensor_id": {
                "help": "Identifier for the current RF sensor (overridden by the physical sensor)",
                "type": "int",
                "min": 0,
                "default": 0
            },
            "loop_delay": {
                "help": "Delay in seconds for each sensor loop",
                "type": "float",
                "min": 0.0,
                "default": 0.01
            },
            "startup_delay": {
                "help": "Delay in seconds to wait after initializing the sensor",
                "type": "float",
                "min": 0.0,
                "default": 1.0
            }
        }
    },
    "xbee_configurator": {
        "name": "XBee configurator",
        "parent": "zigbee_base",
        "settings": {
            "pan_id": {
                "help": "Personal area network identifier",
                "type": "int",
                "min": 0,
                "max": 65535,
                "default": 2015
            }
        }
    },
    "rf_sensor_simulator": {
        "name": "RF sensor simulator",
        "parent": "zigbee_base",
        "settings": {
            "socket_ip": {
                "help": "IP address for connecting the socket",
                "type": "string",
                "required": false,
                "default": "127.0.0.1"
            },
            "socket_port": {
                "help": "Port for connecting the socket",
                "type": "int",
                "min": 0,
                "max": 65535,
                "default": 3233
            },
            "buffer_size": {
                "help": "Number of bytes to read from the socket at once",
                "type": "int",
                "min": 1,
                "default": 256
            }
        }
    },
    "rf_sensor_physical": {
        "name": "RF sensor physical",
        "parent": "zigbee_base",
        "settings": {
            "port": {
                "help": "Device name or port of the RF sensor to use. This overrides the USB manager detection.",
                "type": "string",
                "required": false,
                "default": ""
            },
            "ntp_delay": {
                "help": "Delay in seconds to wait before retrying a synchronization attempt",
                "type": "float",
                "min": 0.0,
                "default": 3.0
            },
            "synchronize": {
                "help": "Whether to synchronize the clock using the NTP algorithm, which is required for TDMA scheduling to work correctly. The program must run as root to do so.",
                "type": "bool",
                "default": false
            }
        }
    },
    "rf_sensor_physical_xbee": {
        "name": "RF sensor physical (XBee)",
        "parent": "rf_sensor_physical",
        "settings": {
            "sensors": {
                "help": "Addresses of all devices in the network, ordered by their identifier",
                "type": "list",
                "subtype": "string",
                "default": [
                    "\\x00\\x13\\xa2\\x00@\\xe6n\\xbd",
                    "\\x00\\x13\\xa2\\x00@\\xe6o5",
                    "\\x00\\x13\\xa2\\x00@\\xe6n\\xb9"
                ]
            },
            "response_delay": {
                "help": "Delay in seconds to wait for a response to a command sent to an RF sensor",
                "type": "float",
                "min": 0.0,
                "default": 0.3
            }
        }
    },
    "rf_sensor_physical_texas_instruments": {
        "name": "RF sensor physical (Texas Instruments)",
        "parent": "rf_sensor_physical",
        "settings": {
            "packet_length": {
                "help": "Number of bytes in the serialized packet",
                "type": "int",
                "min": 0,
                "max": 255,
                "default": 80
            },
            "polling_delay": {
                "help": "Delay in seconds before attempting to shift the schedule when the sensor does not receive anything",
                "type": "float",
                "min": 0.0,
                "default": 2.0
            },
            "reset_delay": {
                "help": "Delay in seconds before changing the reset pulse",
                "type": "float",
                "min": 0.01,
                "default": 0.02
            },
            "rx_pin": {
                "help": "Raspberry Pi GPIO pin for UART RX",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 10
            },
            "tx_pin": {
                "help": "Raspberry Pi GPIO pin for UART TX",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 8
            },
            "rts_pin": {
                "help": "Raspberry Pi GPIO pin for UART RTS",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 11
            },
            "cts_pin": {
                "help": "Raspberry Pi GPIO pin for UART CTS",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 36
            },
            "reset_pin": {
                "help": "Raspberry Pi GPIO pin for resetting the sensor",
                "type": "int",
                "min": 1,
                "max": 40,
                "default": 40
            },
            "shift_minimum": {
                "help": "Minimum number of seconds to shift the schedule",
                "type": "float",
                "min": 0.0,
                "default": 0.1
            },
            "shift_maximum": {
                "help": "Maximum number of seconds to shift the schedule",
                "type": "float",
                "min": 0.0,
                "default": 0.9
            }
        }
    },
    "zigbee_tdma_scheduler": {
        "name": "ZigBee TDMA scheduler",
        "parent": "zigbee_base",
        "settings": {
            "sweep_delay": {
                "help": "Delay in seconds for each sweep",
                "type": "float",
                "min": 0.0,
                "default": 0.9
            }
        }
    },
    "test_base": {
        "name": "Test bench base",
        "settings": {
            "test_class_prefix": {
                "help": "Prefix of class names which are considered to be test classes",
                "type": "string",
                "default": "Test"
            },
            "test_method_prefix": {
                "help": "Prefix of method names which are considered to be test methods",
                "type": "string",
                "default": "test"
            }
        }
    },
    "test_runner": {
        "name": "Test runner",
        "parent": "test_base",
        "settings": {
            "pattern": {
                "help": "Shell-style pattern that determines tests to run. Only tests in files that match are included.",
                "type": "string",
                "default": "*.py"
            },
            "verbosity": {
                "help": "Level of verboseness of the test runner",
                "type": "int",
                "min": 0,
                "default": 1
            },
            "coverage": {
                "help": "Provide a code coverage report",
                "type": "bool",
                "default": true
            },
            "default_branch": {
                "help": "Git branch that is the default from which other branches fork",
                "type": "string",
                "default": "master"
            }
        }
    },
    "test_result": {
        "name": "Test result formatter",
        "parent": "test_base",
        "settings": {
            "profile_sort": {
                "help": "Sort method to use for the profile statistics",
                "type": "string",
                "keys": ["pstats", "Stats", "sort_arg_dict_default"],
                "default": "tottime"
            },
            "profile_limit": {
                "help": "Maximum number of items to show from the profile statistics",
                "type": "int",
                "min": 0,
                "default": 7
            }
        }
    },
    "test_method_coverage": {
        "name": "Test bench method coverage report",
        "parent": "test_base",
        "settings": {
            "init_test_methods": {
                "help": "Test method names, excluding prefix, that cover an `__init__` method",
                "type": "list",
                "subtype": "string",
                "default": ["init", "initialization"]
            },
            "interface_test_methods": {
                "help": "Test method names, excluding prefix, that cover the properties of a class",
                "type": "list",
                "subtype": "string",
                "default": ["interface"]
            }
        }
    }
}
